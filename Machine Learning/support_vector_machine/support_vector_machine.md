# Support Vector Machine

## Εισαγωγή

- Απαιτούν σαν είσοδο διανύσματα **x** μαζί με τους στόχους t.
- **Μάθηση με επίβλεψη**
- Βάση στον **τετραγωνικό προγραμματισμό.**
- **Ρηχό μοντέλο μάθησης** γιατί περιέχει μόνο 2 στρώματα υπολογιστικών μονάδων
<br/> 
<br/>

<img src="images/svm_neuron.jpg"/>


<br/> 
<br/>
<br/>
<br/>
<br/>

<img src="./images/about_margin.jpg">

**Σκοπός** : Η μεγιστοποίηση περιθωρίου ανάμεσα από τα οριακά πρότυπα, έτσι ώστε σε επόμενη προσθήκη προτύπου, να **ελαχιστοποιείται η πιθανότητα** το πρότυπο αυτό να θεωρηθεί της απέναντι κλάσης.


Ψάχνουμε την ευθεία γραμμή που θα **χωρίζει βέλτιστα** τα πρότυπα σε κλάσεις αλλά και θα έχει το **μέγιστο δυνατό περιθώριο**.

### Περιθώριο ταξινόμησης

Περιθώριο : γ = min( γ0, γ1 )

|                 Στοιχείο                 |               Τύπος               |
| :--------------------------------------: | :-------------------------------: |
| Απόσταση από το διαχωριστικό υπερεπίπεδο | <img src="./images/distance.jpg"> |
|                Περιθώριο                 |  <img src="./images/margin.jpg">  |

#### Μεγιστοποίηση Περιθωρίου ταξινόμησης

θέλουμε να βρούμε τις τιμές **w**, b.

<img src="./images/target_weight_bias.jpg">

> με το argmax εννοούμε πως ψάχνουμε τις τιμές **w**,b για τις οποίες η τιμή της συνάρτησης **μεγιστοποιείται.** 

<br/>
<br/>

Δύο Προσεγγίσεις

|                          Παρονομαστής = 1                          |                            Αριθμητής = 1                             |
| :----------------------------------------------------------------: | :------------------------------------------------------------------: |
|     Μεγιστοποίηση <br/> <img src="images/arg_numerator.jpg"/>      |    Ελαχιστοποίηση <br/>  <img src="images/arg_denominator.jpg"/>     |
| Περιορισμός <br/> <img src="images/arg_numerator_limitation.jpg"/> | Περιορισμός <br/> <img src="images/arg_denominator_limitation.jpg"/> |
|                                                                    |                        Απλούστερη Προσέγγιση                         |

<br/>
<br/>

|                           Διανύσματα υποστήριξης                            |                                    Υπόλοιπα                                     |
| :-------------------------------------------------------------------------: | :-----------------------------------------------------------------------------: |
|                      γνωστά και ως **Οριακά πρότυπα**                       |                         γνωστά και ως **καλά πρότυπα**                          |
| Πρότυπα x για τα οποία ισχύει<br/> <img src="./images/support_vector.jpg"/> | Πρότυπα x για τα οποία ισχύει:<br/> <img src="./images/svm_simple_vectors.jpg"> |
|                         βρίσκονται πάνω στο margin                          |                           βρίσκονται πέρα από margin                            |
|              <img src="./images/svm_support_vectors_map.jpg">               |                 <img src="./images/svm_simple_vectors_map.jpg">                 |
|                                     λ>0                                     |                                       λ=0                                       |

<br/>
<br/>

## Λύση 1 : Τετραγωνικός Προγραμματισμός (Primal)

### Με λίγα λόγια
Σκοπός:

|        Ελάχιστο Συνάρτησης         |                Περιορισμοί                |
| :--------------------------------: | :---------------------------------------: |
| <img src="images/square_algo.jpg"> | <img src="images/square_limitations.jpg"> |

Στη δική μας περίπτωση,Θέτουμε:  
<img src="./images/square_NN.jpg">

<br/>
<br/>

## Λύση 2 : Δυικό Πρόβλημα (Dual)


Υπολογίζουμε τα βάρη **w** με βάση:  

<img src="./images/dual_problem_weights.jpg">

όπου στην ουσία ψάχνουμε το **λ** το οποίο βρίσκεται από τον τύπο 

<img src="./images/minimum_lamda.jpg">





<br/>
<br/>

| Σύμβολο |                                Επεξήγηση                                |
| :-----: | :---------------------------------------------------------------------: |
|    Q    | Εσωτερικό γινόμενο διανυσμάτων<br/> <img src="./images/Q_formula.jpg"/> |
|    g    |                        Διάνυσμα με τιμές **-1**                         |
|    λ    |                           Lagrange Multiplier                           |

<br/>
<br/>
<br/>


### Πόλωση

|                                                                                                                  |                                       |
| :--------------------------------------------------------------------------------------------------------------: | :-----------------------------------: |
|                                          Για τη βέλτιστη πόλωση ισχύει:                                          | <img src="./images/optimal_bias.jpg"> |
| Αλλά, για λόγους αριθμητικής ακρίβειας ισχύει όπου έχουμε το **μέσο όρο** για όλα τα **διανύσματα υποστήριξης**. |  <img src="./images/mean_bias.jpg">   |



### Μη γραμμικά διαχωρίσιμα προβλήματα

Εισαγωγή σε κάθε πρότυπο μια μεταβλητή χαραλότητας **ξ** (slack variable)

<img src="./images/insert_slack_variable.jpg">

και ισχυέι ότι το άθροισμα των ξ > πλήθος λάθος ταξινομημένων προτύπων

Το ξ πρακτικά μας δείχνει **πόσο** το πρότυπο έχει **παραβιάσει το margin**.

#### Θέση του ξ

<img src="./images/ksi.jpg">

#### Νέα συνάρτηση Κόστους

<img src="./images/new_cost_function.jpg">

όπου η C είναι μια σταθερά κόστους για την οποία ισχύει:  
Όσο μικρότερη, τόσο αγνοώ τις μεταβλητές χαλαρότητας, άρα το σύστημα δεν πιέζεται για τη βελτιστοποίηση της ταξινόμησης.

Και σκοπός είναι να ικανοποιούνται οι ανισότητες :  

<img src="./images/new_cost_function2.jpg">

#### Τιμές του λ

- Αν x κάτω από το margin τότε C=λ (κακό πρότυπο)
- Αν x πάνω στο margin τότε C>λ>0 (οριακό πρότυπο)
- Αν x πάνω από margin τότε λ=0 (καλό πρότυπο)

<img src="./images/value_of_lamda.jpg">



### Δυικό πρόβλημα vs Νέο Δυικό Πρόβλημα

|                                                     Δυικό                                                     |                                                   Νέο Δυικό                                                   |
| :-----------------------------------------------------------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------: |
|   καλό πρότυπο <span style="color:green">(κοινό)</span> <br/> <img src="./images/svm_simple_vectors.jpg"/>    |   καλό πρότυπο <span style="color:green">(κοινό)</span> <br/> <img src="./images/svm_simple_vectors.jpg"/>    |
|     οριακό πρότυπο <span style="color:green">(κοινό)</span><br/><img src="./images/support_vector.jpg"/>      |     οριακό πρότυπο <span style="color:green">(κοινό)</span><br/> <img src="./images/support_vector.jpg"/>     |
|                                                       -                                                       |                           κακό πρότυπο <br/> <img src="./images/bad_vectors.jpg"/>                            |
| βέλτιστο διάνυσμα <span style="color:green">(κοινό)</span><br/> <img src="./images/dual_problem_weights.jpg"> | βέλτιστο διάνυσμα <span style="color:green">(κοινό)</span> <br/><img src="./images/dual_problem_weights.jpg"> |
|      βέλτιστη πόλωση <span style="color:green">(κοινό)</span> <br/><img src="./images/optimal_bias.jpg">      |     βέλτιστη πόλωση  <span style="color:green">(κοινό)</span> <br/> <img src="./images/optimal_bias.jpg">     |
|   Ελάχιστο συνάρτησης <span style="color:green">(κοινό)</span> <br/><img src="./images/minimum_lamda.jpg">    |  Ελάχιστο συνάρτησης  <span style="color:green">(κοινό)</span> <br/> <img src="./images/minimum_lamda.jpg">   |
|      Τιμή του λ <span style="color:red">!!!</span> <br/> <img src="./images/dual_lamda_limitations.jpg">      |    Τιμή του λ <span style="color:red">!!!</span> <br/> <img src="./images/new_dual_lamda_limitations.jpg">    |

## Primal ή Dual;

Και τα δύο είναι ισοδύναμα.  
Ο στόχος του προβλήματος είναι η εύρεση **w**,b.  

Επιλέγουμε,  

**Dual** : όταν η διάσταση του **w** είναι **μικρότερη** από το πλήθος των προτύπων Ν . 

**Primal** : όταν η διάσταση του **w** είναι **μεγαλύτερη** από το πλήθος των προτύπων Ν.


## Διαχωρισμός μη Γραμμικών Κλάσεων

### Μετασχηματισμός του προβλήματος σε άλλο χώρο

|             Υπολογισμός κόστους             |
| :-----------------------------------------: |
| <img src="./images/new_cost_function2.jpg"> |

Μετατροπές : 

|  Μετατροπή  |                  Εικόνα                  |
| :---------: | :--------------------------------------: |
|   Πρότυπα   |       <img src="./images/phi.jpg">       |
| Περιορισμοί | <img src="./images/phi_limitations.jpg"> |


### Συναρτήσεις Kernel

Ακόμη και σε περιπτώσεις περισσότερων διαστάσεων, έστω 1000, δεν έχουμε πρόβλημα με τα **w**, γιατί δεν χρειάζεται να υπολογίσουμε ούτε τα **w** ούτε το Φ(x).

Το μόνο που χρειάζεται να υπολογίσουμε είναι ο lagrange multiplier.

<img src="./images/phi_lagrange.jpg">

#### Τύπος

Ορίζουμε την συνάρτηση kernel όπου: 

<img src="./images/kernel.jpg">

η οποία επιστρέφει **αριθμό**.

#### Kernel Δυικό Πρόβλημα

|          Στοιχείο           |                      Επεξήγηση                      |
| :-------------------------: | :-------------------------------------------------: |
| Ελάχιστο συνάρτησης κόστους |        <img src="images/minimum_lamda.jpg">         |
|         Περιορισμοί         | <img src="./images/new_dual_lamda_limitations.jpg"> |
|         Παρατήρηση          |          <img src="./images/kernel_q.jpg">          |

>Δεν χρειάζεται να γνωρίζουμε τη συνάρτηση Φ() για να υπολογίσουμε τα Q,g. Χρειαζόαμστε μόνο την Κ().
> - Κάθε συνα΄ρτηση Φ() παράγει έναν πυρήνα.
> - Μερικές φορές, η συνα΄ρτηση Φ() έχει άπειρε διαστάσεις.


##### Kernel Trick

1. Επιλογή συνάρτηση πυρήνα K(**a,b**) που να παράγεται από κάποια συνα΄ρτηση Φ ως Κ(**a,b**) = Φ(**a**)Φ(**b**)
    - Δεν μας νοιάζει ποια είνια η Φ(), αρκεί να ξέρουμε ότι υπάρχει.
    - Δεν είναι όλες οι συναρτήσεις Κ() πυρηνικές. Πρέπει να ικανοποιούν τις προύποθέσεις του θεωρήματος <a href="ikee.lib.auth.gr/record/131347/files/bouzas.pdf#page=43" target="_blank" >Mercer.</a>
2. Υπολογίζουμε το **Q** στο δυϊκό πρόβλημα χρησιμοποιώντας την Κ.
3. Λύνουμε το Δυϊκό.


#### Συνηθισμένοι Πυρήνες

<img src="images/known_kernels.jpg"/>


#### Λύση

Σύμφωνα με όσα έχουμε πει, τα βέλτιστα **w**,b είναι 

<img src="images/phi_solution.jpg">

Ισχύει:

- Αν θέλουμε το **w** είναι απαραίτητη η Φ...
- ΑΛΛΑ, δεν δίνουμε δεκάρα για το **w**!
- Αυτό που μας νοιάζει είναι η έξοδος του ταξινομητή: 

<img src="images/phi_exodus.jpg"/>


### Παραδείγματα Πυρήνων

<img src="images/kernel_examples.jpg"/>

Όσο μεγαλύτερο το σ, τόσο μεγαλύτερες οι καμπάνες / εμβέλεια που καλύπτουν τα πρότυπα, άρα μεγαλύτερη έκταση της κλάσης.


### Πλεονεκτήματα και ανοικτά θέματα


| Πλεονεκτήματα                          | Προβληματάκια                                                                                                                                          |
| :------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------- |
| Λύση γραμμικών & Γραμμικών προβλημάτων | Άγνωστη βέλτιστη επιλογή πυρήνα. Χρειάζονται δοκιμές                                                                                                   |
| Πολύ υψηλή επίδοση                     | Προβλήματα μεγάλου μεγέθους (Big data). Όσο περισσότερα τα πρότυπα Ν, τόσο περισσότερες οι πράξεις στον υπολογισμό του πίνακα **Q** όπου ισχύει Ν * Ν. |
| Βέλτιστο περιθώριο -> Καλή γενίκευση.  | Άγνωστος τρόπος παραλληλοποίησης αλγορίθμου                                                                                                            |
|                                        | Ρηχό μοντέλο μάθησης                                                                                                                                   |


### Σημειώσεις

- Όσο μεγαλώνει το γ, τόσο βελτιώνεται και το σφάλμα στο TR set.
- Μετά από ένα σημείο, όσο μεγλώνει το γ, το σφάλμα χειροτερεύει.
- τα γ και C λέγονται ***ύπερ παράμετροι***. Δίνονται από το **χρήστη** και **δεν εκπαιδεύονται** από το μοντέλο.
- Οι γ και C επιλέγονται με τη μέθοδο της δοκιμής και σφάλματος.  